{
  "version": 3,
  "sources": ["../../../../../../node_modules/@angular/core/fesm2022/rxjs-interop.mjs"],
  "sourcesContent": ["/**\r\n * @license Angular v21.0.6\r\n * (c) 2010-2025 Google LLC. https://angular.dev/\r\n * License: MIT\r\n */\r\n\r\nimport { Observable, ReplaySubject } from 'rxjs';\r\nimport { takeUntil } from 'rxjs/operators';\r\nimport { assertInInjectionContext, inject, DestroyRef, RuntimeError, Injector, effect, untracked, assertNotInReactiveContext, signal, PendingTasks } from './_untracked-chunk.mjs';\r\nimport { getOutputDestroyRef, computed, resource, encapsulateResourceError } from './_resource-chunk.mjs';\r\nimport './_effect-chunk.mjs';\r\nimport './_not_found-chunk.mjs';\r\nimport '@angular/core/primitives/signals';\r\nimport '@angular/core/primitives/di';\r\nimport './_linked_signal-chunk.mjs';\r\n\r\nfunction takeUntilDestroyed(destroyRef) {\r\n  if (!destroyRef) {\r\n    ngDevMode && assertInInjectionContext(takeUntilDestroyed);\r\n    destroyRef = inject(DestroyRef);\r\n  }\r\n  const destroyed$ = new Observable(subscriber => {\r\n    if (destroyRef.destroyed) {\r\n      subscriber.next();\r\n      return;\r\n    }\r\n    const unregisterFn = destroyRef.onDestroy(subscriber.next.bind(subscriber));\r\n    return unregisterFn;\r\n  });\r\n  return source => {\r\n    return source.pipe(takeUntil(destroyed$));\r\n  };\r\n}\r\n\r\nclass OutputFromObservableRef {\r\n  source;\r\n  destroyed = false;\r\n  destroyRef = inject(DestroyRef);\r\n  constructor(source) {\r\n    this.source = source;\r\n    this.destroyRef.onDestroy(() => {\r\n      this.destroyed = true;\r\n    });\r\n  }\r\n  subscribe(callbackFn) {\r\n    if (this.destroyed) {\r\n      throw new RuntimeError(953, ngDevMode && 'Unexpected subscription to destroyed `OutputRef`. ' + 'The owning directive/component is destroyed.');\r\n    }\r\n    const subscription = this.source.pipe(takeUntilDestroyed(this.destroyRef)).subscribe({\r\n      next: value => callbackFn(value)\r\n    });\r\n    return {\r\n      unsubscribe: () => subscription.unsubscribe()\r\n    };\r\n  }\r\n}\r\nfunction outputFromObservable(observable, opts) {\r\n  ngDevMode && assertInInjectionContext(outputFromObservable);\r\n  return new OutputFromObservableRef(observable);\r\n}\r\n\r\nfunction outputToObservable(ref) {\r\n  const destroyRef = getOutputDestroyRef(ref);\r\n  return new Observable(observer => {\r\n    const unregisterOnDestroy = destroyRef?.onDestroy(() => observer.complete());\r\n    const subscription = ref.subscribe(v => observer.next(v));\r\n    return () => {\r\n      subscription.unsubscribe();\r\n      unregisterOnDestroy?.();\r\n    };\r\n  });\r\n}\r\n\r\nfunction toObservable(source, options) {\r\n  if (ngDevMode && !options?.injector) {\r\n    assertInInjectionContext(toObservable);\r\n  }\r\n  const injector = options?.injector ?? inject(Injector);\r\n  const subject = new ReplaySubject(1);\r\n  const watcher = effect(() => {\r\n    let value;\r\n    try {\r\n      value = source();\r\n    } catch (err) {\r\n      untracked(() => subject.error(err));\r\n      return;\r\n    }\r\n    untracked(() => subject.next(value));\r\n  }, {\r\n    injector,\r\n    manualCleanup: true\r\n  });\r\n  injector.get(DestroyRef).onDestroy(() => {\r\n    watcher.destroy();\r\n    subject.complete();\r\n  });\r\n  return subject.asObservable();\r\n}\r\n\r\nfunction toSignal(source, options) {\r\n  typeof ngDevMode !== 'undefined' && ngDevMode && assertNotInReactiveContext(toSignal, 'Invoking `toSignal` causes new subscriptions every time. ' + 'Consider moving `toSignal` outside of the reactive context and read the signal value where needed.');\r\n  const requiresCleanup = !options?.manualCleanup;\r\n  if (ngDevMode && requiresCleanup && !options?.injector) {\r\n    assertInInjectionContext(toSignal);\r\n  }\r\n  const cleanupRef = requiresCleanup ? options?.injector?.get(DestroyRef) ?? inject(DestroyRef) : null;\r\n  const equal = makeToSignalEqual(options?.equal);\r\n  let state;\r\n  if (options?.requireSync) {\r\n    state = signal({\r\n      kind: 0\r\n    }, {\r\n      equal,\r\n      ...(ngDevMode ? createDebugNameObject(options?.debugName, 'state') : undefined)\r\n    });\r\n  } else {\r\n    state = signal({\r\n      kind: 1,\r\n      value: options?.initialValue\r\n    }, {\r\n      equal,\r\n      ...(ngDevMode ? createDebugNameObject(options?.debugName, 'state') : undefined)\r\n    });\r\n  }\r\n  let destroyUnregisterFn;\r\n  const sub = source.subscribe({\r\n    next: value => state.set({\r\n      kind: 1,\r\n      value\r\n    }),\r\n    error: error => {\r\n      state.set({\r\n        kind: 2,\r\n        error\r\n      });\r\n      destroyUnregisterFn?.();\r\n    },\r\n    complete: () => {\r\n      destroyUnregisterFn?.();\r\n    }\r\n  });\r\n  if (options?.requireSync && state().kind === 0) {\r\n    throw new RuntimeError(601, (typeof ngDevMode === 'undefined' || ngDevMode) && '`toSignal()` called with `requireSync` but `Observable` did not emit synchronously.');\r\n  }\r\n  destroyUnregisterFn = cleanupRef?.onDestroy(sub.unsubscribe.bind(sub));\r\n  return computed(() => {\r\n    const current = state();\r\n    switch (current.kind) {\r\n      case 1:\r\n        return current.value;\r\n      case 2:\r\n        throw current.error;\r\n      case 0:\r\n        throw new RuntimeError(601, (typeof ngDevMode === 'undefined' || ngDevMode) && '`toSignal()` called with `requireSync` but `Observable` did not emit synchronously.');\r\n    }\r\n  }, {\r\n    equal: options?.equal,\r\n    ...(ngDevMode ? createDebugNameObject(options?.debugName, 'source') : undefined)\r\n  });\r\n}\r\nfunction makeToSignalEqual(userEquality = Object.is) {\r\n  return (a, b) => a.kind === 1 && b.kind === 1 && userEquality(a.value, b.value);\r\n}\r\nfunction createDebugNameObject(toSignalDebugName, internalSignalDebugName) {\r\n  return {\r\n    debugName: `toSignal${toSignalDebugName ? '#' + toSignalDebugName : ''}.${internalSignalDebugName}`\r\n  };\r\n}\r\n\r\nfunction pendingUntilEvent(injector) {\r\n  if (injector === undefined) {\r\n    ngDevMode && assertInInjectionContext(pendingUntilEvent);\r\n    injector = inject(Injector);\r\n  }\r\n  const taskService = injector.get(PendingTasks);\r\n  return sourceObservable => {\r\n    return new Observable(originalSubscriber => {\r\n      const removeTask = taskService.add();\r\n      let cleanedUp = false;\r\n      function cleanupTask() {\r\n        if (cleanedUp) {\r\n          return;\r\n        }\r\n        removeTask();\r\n        cleanedUp = true;\r\n      }\r\n      const innerSubscription = sourceObservable.subscribe({\r\n        next: v => {\r\n          originalSubscriber.next(v);\r\n          cleanupTask();\r\n        },\r\n        complete: () => {\r\n          originalSubscriber.complete();\r\n          cleanupTask();\r\n        },\r\n        error: e => {\r\n          originalSubscriber.error(e);\r\n          cleanupTask();\r\n        }\r\n      });\r\n      innerSubscription.add(() => {\r\n        originalSubscriber.unsubscribe();\r\n        cleanupTask();\r\n      });\r\n      return innerSubscription;\r\n    });\r\n  };\r\n}\r\n\r\nfunction rxResource(opts) {\r\n  if (ngDevMode && !opts?.injector) {\r\n    assertInInjectionContext(rxResource);\r\n  }\r\n  return resource({\r\n    ...opts,\r\n    loader: undefined,\r\n    stream: params => {\r\n      let sub;\r\n      const onAbort = () => sub?.unsubscribe();\r\n      params.abortSignal.addEventListener('abort', onAbort);\r\n      const stream = signal({\r\n        value: undefined\r\n      });\r\n      let resolve;\r\n      const promise = new Promise(r => resolve = r);\r\n      function send(value) {\r\n        stream.set(value);\r\n        resolve?.(stream);\r\n        resolve = undefined;\r\n      }\r\n      const streamFn = opts.stream ?? opts.loader;\r\n      if (streamFn === undefined) {\r\n        throw new RuntimeError(990, ngDevMode && `Must provide \\`stream\\` option.`);\r\n      }\r\n      sub = streamFn(params).subscribe({\r\n        next: value => send({\r\n          value\r\n        }),\r\n        error: error => {\r\n          send({\r\n            error: encapsulateResourceError(error)\r\n          });\r\n          params.abortSignal.removeEventListener('abort', onAbort);\r\n        },\r\n        complete: () => {\r\n          if (resolve) {\r\n            send({\r\n              error: new RuntimeError(991, ngDevMode && 'Resource completed before producing a value')\r\n            });\r\n          }\r\n          params.abortSignal.removeEventListener('abort', onAbort);\r\n        }\r\n      });\r\n      return promise;\r\n    }\r\n  });\r\n}\r\n\r\nexport { outputFromObservable, outputToObservable, pendingUntilEvent, rxResource, takeUntilDestroyed, toObservable, toSignal };\r\n\r\n"],
  "mappings": "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",
  "names": []
}
